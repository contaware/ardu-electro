Pins
----

1. On AVR platform pins are of type byte (uint8_t), even if many people 
use int. The most common functions are:
* void pinMode(uint8_t pin, uint8_t mode)
* void digitalWrite(uint8_t pin, uint8_t val)     AVR takes ~5us
* int digitalRead(uint8_t pin)                    AVR takes ~5us
* void analogWrite(uint8_t pin, int val)          AVR takes ~5us
* int analogRead(uint8_t pin)                     AVR takes ~100us
Attention: for the digital functions always use LOW and HIGH enum.
   
2. AVR pins default to inputs (high-impedance state), so they don't need
to be explicitly declared as inputs with pinMode(). Because they are in
a high-impedance state, when switching mode to OUTPUT, we can safely 
assume that the output will be LOW (see explanation from point 3.). 
This holds only for AVR, for other platforms it is not guaranteed!

3. There are 20K pullup resistors built into the AVR chips that can be 
accessed by setting the pinMode() to INPUT_PULLUP. The pullup resistors
are controlled by the same registers (internal chip memory locations) 
that control whether a pin is HIGH or LOW. Consequently, an input pin 
that is configured to have pullup resistors turned on, will output a 
HIGH if it is switched to OUTPUT mode. Note that some documents
erroneously state that switching from OUTPUT mode to INPUT mode will 
leave the pullup state untouched, that used to be so before the 
introduction of INPUT_PULLUP, but now switching to INPUT always disables
pullups and switching to INPUT_PULLUP always enables pullups. Before the 
introduction of INPUT_PULLUP people had to enabled the pullups in two
steps (this still works if pinMode is called before digitalWrite): 
pinMode(pin, INPUT);
digitalWrite(pin, HIGH); // turn on pullup resistor

4. AVR do not have DAC, but some digital pins can be used as PWM for
analog output.

5. AVR have analog input pins connected to the channels of one 10-bit 
ADC, those pins can also be used as digital input/output pins, except 
the A6 and A7 of the NANO, PRO MINI and MINIs which are analog inputs 
only. These two analog inputs are not available on the UNO because the 
DIP28 package does not have enough pins. It is possible with the TQFP 
SMD package because it has 32 pins. The analog pins also have pull-up 
resistors, which work identically to pull-up resistors on the digital 
pins. 

The analog pins can be used as digital pins like digitalRead(A0), look
at the following predefined constants:
#define PIN_A0   (14)        or        #define PIN_A0   (54) // for MEGA
...                                    ...
#define PIN_A7   (21)        or        #define PIN_A15  (69) // for MEGA
static const uint8_t A0 = PIN_A0;
...

To have analogRead(A0) == analogRead(0),... analogRead() does:
if (pin >= 14) pin -= 14;    or    if (pin >= 54) pin -= 54; // for MEGA 

Attention: for non-AVRs, like ESP32, please only use A0, A1, A2,... as
passing 0, 1, 2,... is not working. Also remember that ESP32 disables 
all inputs that direct to the ADC2 when WiFi is in use.


Do not power Arduinos through I/O pins!
---------------------------------------

If power is disconnected then current can flow from an I/O pin through 
the internal clamping diodes to the Vcc line and boot the device. Those 
diodes are however not designed to handle much current, avoid that by 
also disconnecting the ground or add a 10k resistor to the I/O pin.


LED pin
-------

On the official UNO the LED pin 13 is buffered with an opamp, so you 
can use pin 13 freely. On many boards though, the LED is just connected 
directly to the pin, and the load from the LED prevents it from being a 
useful input. The symptom of this (with INPUT_PULLUP set) would be:  
a dim LED and the digitalRead() always returning low. 


Output pin current
------------------

If you drive a mosfet from an Arduino pin without a series resistor, 
then every time the mosfet switches, the input capacitance of the 
mosfet has to be charged or discharged. This results in a current 
pulse, the amplitude of which is limited by the internal resistance of 
the pin given by its mosfets' Rds(on). This resistance is around 20 ohm,
so the peak current into or out of the Arduino pin can be as high as 
200mA, way above the absolute maximum rating of 40mA. If we take a 
typical power mosfet with a total gate charge of 20nC, the pulse will 
last for about 100ns. Is a 100ns current pulse of 5x the absolute 
maximum continuous current rating likely to damage the Arduino? I 
suspect the answer is that nobody knows. However, as Atmel does not 
specify a pulse current rating for the output pins, we have to take the 
view that it might. So a series resistor is recommended. A 100 ohm 
series resistor will result in a 40mA pulse lasting about 500ns instead.


Emulate an open drain output using and external pull-up resistor
----------------------------------------------------------------

void digitalWriteOpenDrain(uint8_t pin, uint8_t val)
{ 
  if (val == HIGH)
  {
    pinMode(pin, INPUT);
	digitalWrite(pin, LOW); // remove built-in pull-up in case it was HIGH
  }
  else
  { 
    // Above we cannot use pinMode(pin, INPUT_PULLUP) because:
	// 1. The following digitalWrite(pin, LOW) would remove the pull-up resistor 
	//    for a moment before switching to OUTPUT mode with pinMode(pin, OUTPUT).
	// 2. Inverting the order of the following two commands is even worse because
    //    for a moment the OUTPUT would be HIGH!
    digitalWrite(pin, LOW);
    pinMode(pin, OUTPUT);
  }	
}
-> as the default state for a pin is INPUT and LOW (NOT INPUT_PULLUP), 
   we could simply switch between the modes. 


Power jack vs Vin
-----------------

Power jack connects to Vin through a diode (see datasheet), so if the 
power jack voltage is greater than the voltage applied to Vin, current 
flows in and can damage the power supply connected to Vin.
Hint: put a tape on the power jack if powering directly into Vin.


Vin vs Vusb
-----------

From the datasheet we can see that Vin is being monitored by a voltage 
comparator. When Vin is above 6.6V, the P-channel MOSFET turns OFF 
(the MOSFET body diode can still conduct). When the MOSFET is ON there 
is practically no voltage drop.
On earlier versions of UNO and MEGA and still on NANO, the power source 
selection is performed by a schottky diode which has 0.3-0.4V of voltage 
drop. So that the +5V pin is then only at 4.6-4.7V when operating on USB.
Attention: the LDO regulators have reverse protection diodes, you get 
           power at the Vin pin when supplying from Vusb.


Power jack / Vin safe ranges
----------------------------

Most boards:                       7-12V

Nano 33, Nano RP2040 Connect:      5-18V

MKR, Portenta H7, Nicla Sense ME:  5V
Attention: MKR boards when powered through Vin do not output exactly 5V
           on the 5V pin. Moreover when powered by exactly 5.0V the WiFi
		   NINA module sometimes does not connect, with 5.2-5.3V there 
		   are no problems.

See:
https://docs.arduino.cc/learn/electronics/power-pins


New inclusive language
----------------------

Master In Slave Out (MISO) -> Controller In,  Peripheral Out (CIPO) or
                              Peripheral Out, Controller In  (POCI)
Master Out Slave In (MOSI) -> Controller Out, Peripheral In  (COPI) or 
                              Peripheral In,  Controller Out (PICO)
Slave Select pin (SS)      -> Chip Select Pin (CS)


UNO or NANO communication
-------------------------

SPI on ICSP or on these pins:
MOSI pin 11
MISO pin 12
SCK  pin 13
SS   pin 10

I2C:
SDA  pin A4 (in UNO also second most left pin from AREF)
SCL  pin A5 (in UNO also most left pin from AREF)

Serial (pin 0 & 1 also used for communication with PC):
RX   pin 0
TX   pin 1


MEGA communication 
------------------

SPI on ICSP or on these pins:
MISO pin 50
MOSI pin 51
SCK  pin 52
SS   pin 53

I2C:
SDA  pin 20
SCL  pin 21
Attention: Mega is the only board which has 10k pull-up resistors on
           the SDA and SCL lines!

Serial (pin 0 & 1 also used for communication with PC):
     Serial  Serial1  Serial2  Serial3
RX   pin 0   pin 19   pin 17   pin 15 
TX   pin 1   pin 18   pin 16   pin 14


UNO WIFI REV2 communication
---------------------------

SPI only on ICSP (there is no SS, use any pin):
MISO  ICSP1 --o  o-- ICSP2 VCC
SCK   ICSP3 --o  o-- ICSP4 MOSI
RESET ICSP5 --o  o-- ICSP6 GND

I2C:
SDA  next to AREF pin
SCL  next to SDA pin

Serial:
Serial is connected to the USB interface.
Serial1 is connected to pin 0 (RX) and pin 1 (TX).
Serial2 is connected to the u-blox NINA-W13 module.


ATtiny85 communication
----------------------

Ports (PB0..PB5) are defined in
C:\Program Files (x86)\Arduino\hardware\tools\avr\avr\include\avr\iotnx5.h
included by Arduino.h -> io.h -> iotn85.h -> iotnx5.h

SPI on these pins (there is no SS, use any pin):
MISO PB1 (physical pin 6)
MOSI PB0 (physical pin 5)
SCK  PB2 (physical pin 7)

I2C:
SDA  PB0 (physical pin 5)
SCL  PB2 (physical pin 7)

Software serial with CP2102/PL2303/CH340G USB to TTL cable:
- ATTinyCore by Spence Konde supports Serial.begin() and by default
  TX is on PB0 and RX on PB1. The TX pin can be changed with
  Serial.setTxBit() called before Serial.begin().
  Since 2.0.0 it's possible to choose a TX only mode from Tools ->
  Software Serial menu; read() and peek() will always return -1, and 
  available() will always return 0.
- For Digistump AVR Boards by ArminJo there is the TX only
  ATtinySerialOut.hpp library which uses fixed baud-rates (default is
  115200). TX is by default on PB2, that can be changed with a
  #define TX_PIN PB0 before the #include "ATtinySerialOut.hpp".
- For the Adafruit Trinket boards use the built-in SoftwareSerial lib:
  #include <SoftwareSerial.h>
  SoftwareSerial Serial(PB1, PB0); // RX, TX
  Attention: flash at 8MHz otherwise it does not work.
