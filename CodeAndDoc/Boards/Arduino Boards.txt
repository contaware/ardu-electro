Pins
----

1. On AVR platform pins are of type byte (uint8_t), even if many people 
use int. The most common functions are:
* void pinMode(uint8_t pin, uint8_t mode)
* void digitalWrite(uint8_t pin, uint8_t val)     AVR takes ~5us
* int digitalRead(uint8_t pin)                    AVR takes ~5us
* void analogWrite(uint8_t pin, int val)          AVR takes ~5us
* int analogRead(uint8_t pin)                     AVR takes ~100us
Attention: for the digital functions always use LOW and HIGH enum.
   
2. AVR pins default to inputs (high-impedance state), so they don't need
to be explicitly declared as inputs with pinMode(). Because they are in
a high-impedance state, when switching mode to OUTPUT, we can safely 
assume that the output will be LOW (see explanation from point 3.). 
This holds only for AVR, for other platforms it is not guaranteed!

3. There are 20K pullup resistors built into the AVR chips that can be 
accessed by setting the pinMode() to INPUT_PULLUP. The pullup resistors
are controlled by the same registers (internal chip memory locations) 
that control whether a pin is HIGH or LOW. Consequently, an input pin 
that is configured to have pullup resistors turned on, will output a 
HIGH if it is switched to OUTPUT mode. Note that some documents
erroneously state that switching from OUTPUT mode to INPUT mode will 
leave the pullup state untouched, that used to be so before the 
introduction of INPUT_PULLUP, but now switching to INPUT always disables
pullups and switching to INPUT_PULLUP always enables pullups. Before the 
introduction of INPUT_PULLUP people had to enabled the pullups in two
steps (this still works if pinMode is called before digitalWrite): 
pinMode(pin, INPUT);
digitalWrite(pin, HIGH); // turn on pullup resistor

4. AVR do not have DAC, but some digital pins can be used as PWM for
analog output.

5. AVR have analog input pins connected to the channels of one 10-bit 
ADC, those pins can also be used as digital input/output pins, except 
the A6 and A7 of the NANO, PRO MINI and MINIs which are analog inputs 
only. These two analog inputs are not available on the UNO because the 
DIP28 package does not have enough pins. It is possible with the TQFP 
SMD package because it has 32 pins. The analog pins also have pull-up 
resistors, which work identically to pull-up resistors on the digital 
pins. 

The analog pins can be used as digital pins like digitalRead(A0), look
at the following predefined constants:
#define PIN_A0   (14)        or        #define PIN_A0   (54) // for MEGA
...                                    ...
#define PIN_A7   (21)        or        #define PIN_A15  (69) // for MEGA
static const uint8_t A0 = PIN_A0;
...

To have analogRead(A0) == analogRead(0),... analogRead() does:
if (pin >= 14) pin -= 14;    or    if (pin >= 54) pin -= 54; // for MEGA 


LED pin
-------

On the official UNO the LED pin 13 is buffered with an opamp, so you 
can use pin 13 freely. On many boards though, the LED is just connected 
directly to the pin, and the load from the LED prevents it from being a 
useful input. The symptom of this would be with it set as INPUT_PULLUP, 
the LED would light very dimly, and digitalRead() would always return 
low. 


Emulate an open drain output using and external pull-up resistor
----------------------------------------------------------------

void digitalWriteOpenDrain(uint8_t pin, uint8_t val)
{ 
  if (val == HIGH)
  {
    pinMode(pin, INPUT);
	digitalWrite(pin, LOW); // remove built-in pull-up in case it was HIGH
  }
  else
  { 
    // Above we cannot use pinMode(pin, INPUT_PULLUP) because:
	// 1. The following digitalWrite(pin, LOW) would remove the pull-up resistor 
	//    for a moment before switching to OUTPUT mode with pinMode(pin, OUTPUT).
	// 2. Inverting the order of the following two commands is even worse because
    //    for a moment the OUTPUT would be HIGH!
    digitalWrite(pin, LOW);
    pinMode(pin, OUTPUT);
  }	
}
-> as the default state for a pin is INPUT and LOW (NOT INPUT_PULLUP), 
   we could simply switch between the modes. 


Power jack vs Vin
-----------------

Power jack connects to Vin through a diode (see datasheet), so if the 
power jack voltage is greater than the voltage applied to Vin, current 
flows in and can damage the power supply connected to Vin.
Hint: put a tape on the power jack if powering directly into Vin.


Vin vs Vusb
-----------

From the datasheet we can see that Vin is being monitored by a voltage 
comparator. When Vin is above 6.6V, the P-channel MOSFET turns off 
disconnecting the 5V of the USB. When the MOSFET is conducting there is 
practically no voltage drop.
On earlier versions of UNO and MEGA and still on NANO, the switch is 
done with a schottky diode which has 0.3-0.4V of voltage drop. So that
the +5V pin is then only at 4.6-4.7V when operating on USB.


Power jack / Vin safe ranges
----------------------------

Most boards:                       7-12V / 1A

MKR, Portenta H7, Nicla Sense ME:  5V    / 1A
Attention: MKR boards when powered through Vin do not output exactly 5V
           on the 5V pin. Moreover when powered by exactly 5.0V the WiFi
		   NINA module sometimes does not connect, with 5.2-5.3V there 
		   are no problems.

See:
https://docs.arduino.cc/learn/electronics/power-pins


New "politically correct" terminology
-------------------------------------

Master In Slave Out (MISO) -> Controller In,  Peripheral Out (CIPO) or
                              Peripheral Out, Controller In  (POCI)
Master Out Slave In (MOSI) -> Controller Out, Peripheral In  (COPI) or 
                              Peripheral In,  Controller Out (PICO)
Slave Select pin (SS)      -> Chip Select Pin (CS)


UNO or NANO communication
-------------------------

SPI on ICSP or on these pins:
MOSI pin 11
MISO pin 12
SCK  pin 13
SS   pin 10

I2C:
SDA  pin A4 (in UNO also second most left pin from AREF)
SCL  pin A5 (in UNO also most left pin from AREF)

Serial (pin 0 & 1 also used for communication with PC):
RX   pin 0
TX   pin 1


MEGA communication 
------------------

SPI on ICSP or on these pins:
MISO pin 50
MOSI pin 51
SCK  pin 52
SS   pin 53

I2C:
SDA  pin 20
SCL  pin 21
Attention: Mega is the only board which has 10k pull-up resistors on
           the SDA and SCL lines!

Serial (pin 0 & 1 also used for communication with PC):
     Serial  Serial1  Serial2  Serial3
RX   pin 0   pin 19   pin 17   pin 15 
TX   pin 1   pin 18   pin 16   pin 14


UNO WIFI REV2 communication
---------------------------

SPI only on ICSP (there is no SS, use any pin):
MISO  ICSP1 --o  o-- ICSP2 VCC
SCK   ICSP3 --o  o-- ICSP4 MOSI
RESET ICSP5 --o  o-- ICSP6 GND

I2C:
SDA  next to AREF pin
SCL  next to SDA pin

Serial:
Serial is connected to the USB interface.
Serial1 is connected to pin 0 (RX) and pin 1 (TX).
Serial2 is connected to the u-blox NINA-W13 module.


ATtiny85 communication
----------------------

SPI on these pins (there is no SS, use any pin):
MISO pin 6
MOSI pin 5
SCK  pin 7

I2C:
SDA  pin 5
SCL  pin 7

Serial:
Not supported, use SoftwareSerial.h
